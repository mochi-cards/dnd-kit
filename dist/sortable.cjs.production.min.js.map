{"version":3,"file":"sortable.cjs.production.min.js","sources":["../src/utilities/arrayMove.ts","../src/utilities/isValidIndex.ts","../src/strategies/horizontalListSorting.ts","../src/strategies/rectSorting.ts","../src/strategies/verticalListSorting.ts","../src/components/SortableContext.tsx","../src/hooks/defaults.ts","../src/sensors/keyboard/sortableKeyboardCoordinates.ts","../src/utilities/getSortedRects.ts","../src/utilities/arraySwap.ts","../src/strategies/rectSwapping.ts","../src/hooks/useSortable.ts","../src/hooks/utilities/useDerivedTransform.ts"],"sourcesContent":["/**\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\n */\nexport function arrayMove<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n  newArray.splice(\n    to < 0 ? newArray.length + to : to,\n    0,\n    newArray.splice(from, 1)[0]\n  );\n\n  return newArray;\n}\n","export function isValidIndex(index: number | null): index is number {\n  return index !== null && index >= 0;\n}\n","import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const horizontalListSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeNodeRect: fallbackActiveRect,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index === activeIndex) {\n    const newIndexRect = layoutRects[overIndex];\n\n    if (!newIndexRect) {\n      return null;\n    }\n\n    return {\n      x:\n        activeIndex < overIndex\n          ? newIndexRect.offsetLeft +\n            newIndexRect.width -\n            (activeNodeRect.offsetLeft + activeNodeRect.width)\n          : newIndexRect.offsetLeft - activeNodeRect.offsetLeft,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: -activeNodeRect.width - itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: activeNodeRect.width + itemGap,\n      y: 0,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect: LayoutRect | undefined = layoutRects[index];\n  const previousRect: LayoutRect | undefined = layoutRects[index - 1];\n  const nextRect: LayoutRect | undefined = layoutRects[index + 1];\n\n  if (!currentRect || (!previousRect && !nextRect)) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width)\n      : nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width);\n  }\n\n  return nextRect\n    ? nextRect.offsetLeft - (currentRect.offsetLeft + currentRect.width)\n    : currentRect.offsetLeft - (previousRect.offsetLeft + previousRect.width);\n}\n","import {arrayMove} from '../utilities';\nimport type {SortingStrategy} from '../types';\n\nexport const rectSortingStrategy: SortingStrategy = ({\n  layoutRects,\n  activeIndex,\n  overIndex,\n  index,\n}) => {\n  const newRects = arrayMove(layoutRects, overIndex, activeIndex);\n\n  const oldRect = layoutRects[index];\n  const newRect = newRects[index];\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import type {LayoutRect} from '@dnd-kit/core';\nimport type {SortingStrategy} from '../types';\n\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n  scaleX: 1,\n  scaleY: 1,\n};\n\nexport const verticalListSortingStrategy: SortingStrategy = ({\n  activeIndex,\n  activeNodeRect: fallbackActiveRect,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  const activeNodeRect = layoutRects[activeIndex] ?? fallbackActiveRect;\n\n  if (!activeNodeRect) {\n    return null;\n  }\n\n  if (index === activeIndex) {\n    const overIndexRect = layoutRects[overIndex];\n\n    if (!overIndexRect) {\n      return null;\n    }\n\n    return {\n      x: 0,\n      y:\n        activeIndex < overIndex\n          ? overIndexRect.offsetTop +\n            overIndexRect.height -\n            (activeNodeRect.offsetTop + activeNodeRect.height)\n          : overIndexRect.offsetTop - activeNodeRect.offsetTop,\n      ...defaultScale,\n    };\n  }\n\n  const itemGap = getItemGap(layoutRects, index, activeIndex);\n\n  if (index > activeIndex && index <= overIndex) {\n    return {\n      x: 0,\n      y: -activeNodeRect.height - itemGap,\n      ...defaultScale,\n    };\n  }\n\n  if (index < activeIndex && index >= overIndex) {\n    return {\n      x: 0,\n      y: activeNodeRect.height + itemGap,\n      ...defaultScale,\n    };\n  }\n\n  return {\n    x: 0,\n    y: 0,\n    ...defaultScale,\n  };\n};\n\nfunction getItemGap(\n  layoutRects: LayoutRect[],\n  index: number,\n  activeIndex: number\n) {\n  const currentRect: LayoutRect | undefined = layoutRects[index];\n  const previousRect: LayoutRect | undefined = layoutRects[index - 1];\n  const nextRect: LayoutRect | undefined = layoutRects[index + 1];\n\n  if (!currentRect) {\n    return 0;\n  }\n\n  if (activeIndex < index) {\n    return previousRect\n      ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n      : nextRect\n      ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n      : 0;\n  }\n\n  return nextRect\n    ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height)\n    : previousRect\n    ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height)\n    : 0;\n}\n","import React, {MutableRefObject, useEffect, useMemo, useRef} from 'react';\nimport {useDndContext, LayoutRect, UniqueIdentifier} from '@dnd-kit/core';\nimport {useIsomorphicLayoutEffect, useUniqueId} from '@dnd-kit/utilities';\n\nimport type {SortingStrategy} from '../types';\nimport {getSortedRects} from '../utilities';\nimport {rectSortingStrategy} from '../strategies';\n\nexport interface Props {\n  children: React.ReactNode;\n  items: (UniqueIdentifier | {id: UniqueIdentifier})[];\n  strategy?: SortingStrategy;\n  id?: string;\n}\n\nconst ID_PREFIX = 'Sortable';\n\ninterface ContextDescriptor {\n  activeIndex: number;\n  containerId: string;\n  disableTransforms: boolean;\n  items: UniqueIdentifier[];\n  overIndex: number;\n  useDragOverlay: boolean;\n  sortedRects: LayoutRect[];\n  strategy: SortingStrategy;\n  wasDragging: MutableRefObject<boolean>;\n}\n\nexport const Context = React.createContext<ContextDescriptor>({\n  activeIndex: -1,\n  containerId: ID_PREFIX,\n  disableTransforms: false,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: false,\n  sortedRects: [],\n  strategy: rectSortingStrategy,\n  wasDragging: {current: false},\n});\n\nexport function SortableContext({\n  children,\n  id,\n  items: userDefinedItems,\n  strategy = rectSortingStrategy,\n}: Props) {\n  const {\n    active,\n    dragOverlay,\n    droppableRects,\n    over,\n    recomputeLayouts,\n    willRecomputeLayouts,\n  } = useDndContext();\n  const containerId = useUniqueId(ID_PREFIX, id);\n  const useDragOverlay = Boolean(dragOverlay.rect !== null);\n  const items = useMemo(\n    () =>\n      userDefinedItems.map((item) =>\n        typeof item === 'string' ? item : item.id\n      ),\n    [userDefinedItems]\n  );\n  const isDragging = active != null;\n  const wasDragging = useRef(false);\n  const activeIndex = active ? items.indexOf(active.id) : -1;\n  const isSorting = activeIndex !== -1;\n  const overIndex = over ? items.indexOf(over.id) : -1;\n  const previousItemsRef = useRef(items);\n  const sortedRects = getSortedRects(items, droppableRects);\n  const itemsHaveChanged = !isEqual(items, previousItemsRef.current);\n  const disableTransforms =\n    (overIndex !== -1 && activeIndex === -1) || itemsHaveChanged;\n\n  useIsomorphicLayoutEffect(() => {\n    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {\n      // To-do: Add partial recompution of only subset of rects\n      recomputeLayouts();\n    }\n  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);\n\n  useEffect(() => {\n    previousItemsRef.current = items;\n  }, [items]);\n\n  useEffect(() => {\n    const timeoutId = setTimeout(() => {\n      wasDragging.current = isDragging;\n    }, 100);\n\n    return () => clearTimeout(timeoutId);\n  }, [isDragging]);\n\n  const contextValue = useMemo(\n    (): ContextDescriptor => ({\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      useDragOverlay,\n      sortedRects,\n      strategy,\n      wasDragging,\n    }),\n    [\n      activeIndex,\n      containerId,\n      disableTransforms,\n      items,\n      overIndex,\n      sortedRects,\n      useDragOverlay,\n      strategy,\n      wasDragging,\n    ]\n  );\n\n  return <Context.Provider value={contextValue}>{children}</Context.Provider>;\n}\n\nfunction isEqual(arr1: string[], arr2: string[]) {\n  return arr1.join() === arr2.join();\n}\n","import {CSS} from '@dnd-kit/utilities';\n\nimport {arrayMove} from '../utilities';\n\nimport type {\n  AnimateLayoutChanges,\n  NewIndexGetter,\n  SortableTransition,\n} from './types';\n\nexport const defaultNewIndexGetter: NewIndexGetter = ({\n  id,\n  items,\n  activeIndex,\n  overIndex,\n}) => arrayMove(items, activeIndex, overIndex).indexOf(id);\n\nexport const defaultAnimateLayoutChanges: AnimateLayoutChanges = ({\n  containerId,\n  isSorting,\n  wasDragging,\n  index,\n  items,\n  newIndex,\n  previousItems,\n  previousContainerId,\n  transition,\n}) => {\n  if (!transition || !wasDragging) {\n    return false;\n  }\n\n  if (previousItems !== items && index === newIndex) {\n    return false;\n  }\n\n  if (isSorting) {\n    return true;\n  }\n\n  return newIndex !== index && containerId === previousContainerId;\n};\n\nexport const defaultTransition: SortableTransition = {\n  duration: 200,\n  easing: 'ease',\n};\n\nexport const transitionProperty = 'transform';\n\nexport const disabledTransition = CSS.Transition.toString({\n  property: transitionProperty,\n  duration: 0,\n  easing: 'linear',\n});\n\nexport const defaultAttributes = {\n  roleDescription: 'sortable',\n};\n","import {\n  closestCorners,\n  getViewRect,\n  getScrollableAncestors,\n  KeyboardCode,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n} from '@dnd-kit/core';\n\nconst directions: string[] = [\n  KeyboardCode.Down,\n  KeyboardCode.Right,\n  KeyboardCode.Up,\n  KeyboardCode.Left,\n];\n\nexport const sortableKeyboardCoordinates: KeyboardCoordinateGetter = (\n  event,\n  {context: {active, droppableContainers, translatedRect, scrollableAncestors}}\n) => {\n  if (directions.includes(event.code)) {\n    event.preventDefault();\n\n    if (!active || !translatedRect) {\n      return;\n    }\n\n    const filteredContainers: DroppableContainer[] = [];\n\n    droppableContainers.getEnabled().forEach((entry) => {\n      if (!entry || entry?.disabled) {\n        return;\n      }\n\n      const node = entry?.node.current;\n\n      if (!node) {\n        return;\n      }\n\n      const rect = getViewRect(node);\n      const container: DroppableContainer = {\n        ...entry,\n        rect: {\n          current: rect,\n        },\n      };\n\n      switch (event.code) {\n        case KeyboardCode.Down:\n          if (translatedRect.top + translatedRect.height <= rect.top) {\n            filteredContainers.push(container);\n          }\n          break;\n        case KeyboardCode.Up:\n          if (translatedRect.top >= rect.top + rect.height) {\n            filteredContainers.push(container);\n          }\n          break;\n        case KeyboardCode.Left:\n          if (translatedRect.left >= rect.left + rect.width) {\n            filteredContainers.push(container);\n          }\n          break;\n        case KeyboardCode.Right:\n          if (translatedRect.left + translatedRect.width <= rect.left) {\n            filteredContainers.push(container);\n          }\n          break;\n      }\n    });\n\n    const closestId = closestCorners({\n      active,\n      collisionRect: translatedRect,\n      droppableContainers: filteredContainers,\n    });\n\n    if (closestId) {\n      const newNode = droppableContainers.get(closestId)?.node.current;\n\n      if (newNode) {\n        const newScrollAncestors = getScrollableAncestors(newNode);\n        const hasDifferentScrollAncestors = newScrollAncestors.some(\n          (element, index) => scrollableAncestors[index] !== element\n        );\n        const newRect = getViewRect(newNode);\n        const offset = hasDifferentScrollAncestors\n          ? {\n              x: 0,\n              y: 0,\n            }\n          : {\n              x: translatedRect.width - newRect.width,\n              y: translatedRect.height - newRect.height,\n            };\n        const newCoordinates = {\n          x: newRect.left - offset.x,\n          y: newRect.top - offset.y,\n        };\n\n        return newCoordinates;\n      }\n    }\n  }\n\n  return undefined;\n};\n","import type {\n  LayoutRect,\n  UniqueIdentifier,\n  UseDndContextReturnValue,\n} from '@dnd-kit/core';\n\nexport function getSortedRects(\n  items: UniqueIdentifier[],\n  layoutRects: UseDndContextReturnValue['droppableRects']\n) {\n  return items.reduce<LayoutRect[]>((accumulator, id, index) => {\n    const layoutRect = layoutRects.get(id);\n\n    if (layoutRect) {\n      accumulator[index] = layoutRect;\n    }\n\n    return accumulator;\n  }, Array(items.length));\n}\n","/**\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\n */\nexport function arraySwap<T>(array: T[], from: number, to: number): T[] {\n  const newArray = array.slice();\n\n  newArray[from] = array[to];\n  newArray[to] = array[from];\n\n  return newArray;\n}\n","import type {SortingStrategy} from '../types';\n\nexport const rectSwappingStrategy: SortingStrategy = ({\n  activeIndex,\n  index,\n  layoutRects,\n  overIndex,\n}) => {\n  let oldRect;\n  let newRect;\n\n  if (index === activeIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[overIndex];\n  }\n\n  if (index === overIndex) {\n    oldRect = layoutRects[index];\n    newRect = layoutRects[activeIndex];\n  }\n\n  if (!newRect || !oldRect) {\n    return null;\n  }\n\n  return {\n    x: newRect.offsetLeft - oldRect.offsetLeft,\n    y: newRect.offsetTop - oldRect.offsetTop,\n    scaleX: newRect.width / oldRect.width,\n    scaleY: newRect.height / oldRect.height,\n  };\n};\n","import {useContext, useEffect, useMemo, useRef} from 'react';\nimport {useDraggable, useDroppable, UseDraggableArguments} from '@dnd-kit/core';\nimport {CSS, useCombinedRefs} from '@dnd-kit/utilities';\n\nimport {Context} from '../components';\nimport type {SortingStrategy} from '../types';\nimport {isValidIndex} from '../utilities';\nimport {\n  defaultAnimateLayoutChanges,\n  defaultAttributes,\n  defaultNewIndexGetter,\n  defaultTransition,\n  disabledTransition,\n  transitionProperty,\n} from './defaults';\nimport type {\n  AnimateLayoutChanges,\n  NewIndexGetter,\n  SortableTransition,\n} from './types';\nimport {useDerivedTransform} from './utilities';\n\nexport interface Arguments extends UseDraggableArguments {\n  animateLayoutChanges?: AnimateLayoutChanges;\n  getNewIndex?: NewIndexGetter;\n  strategy?: SortingStrategy;\n  transition?: SortableTransition | null;\n}\n\nexport function useSortable({\n  animateLayoutChanges = defaultAnimateLayoutChanges,\n  attributes: userDefinedAttributes,\n  disabled,\n  data: customData,\n  getNewIndex = defaultNewIndexGetter,\n  id,\n  strategy: localStrategy,\n  transition = defaultTransition,\n}: Arguments) {\n  const {\n    items,\n    containerId,\n    activeIndex,\n    disableTransforms,\n    sortedRects,\n    overIndex,\n    useDragOverlay,\n    strategy: globalStrategy,\n    wasDragging,\n  } = useContext(Context);\n  const index = items.indexOf(id);\n  const data = useMemo(\n    () => ({sortable: {containerId, index, items}, ...customData}),\n    [containerId, customData, index, items]\n  );\n  const {rect, node, setNodeRef: setDroppableNodeRef} = useDroppable({\n    id,\n    data,\n  });\n  const {\n    active,\n    activeNodeRect,\n    activatorEvent,\n    attributes,\n    setNodeRef: setDraggableNodeRef,\n    listeners,\n    isDragging,\n    over,\n    transform,\n  } = useDraggable({\n    id,\n    data,\n    attributes: {\n      ...defaultAttributes,\n      ...userDefinedAttributes,\n    },\n    disabled,\n  });\n  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);\n  const isSorting = Boolean(active);\n  const displaceItem =\n    isSorting &&\n    wasDragging.current &&\n    !disableTransforms &&\n    isValidIndex(activeIndex) &&\n    isValidIndex(overIndex);\n  const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n  const dragSourceDisplacement =\n    shouldDisplaceDragSource && displaceItem ? transform : null;\n  const strategy = localStrategy ?? globalStrategy;\n  const finalTransform = displaceItem\n    ? dragSourceDisplacement ??\n      strategy({\n        layoutRects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index,\n      })\n    : null;\n  const newIndex =\n    isValidIndex(activeIndex) && isValidIndex(overIndex)\n      ? getNewIndex({id, items, activeIndex, overIndex})\n      : index;\n  const prevItems = useRef(items);\n  const itemsHaveChanged = items !== prevItems.current;\n  const prevNewIndex = useRef(newIndex);\n  const previousContainerId = useRef(containerId);\n  const shouldAnimateLayoutChanges = animateLayoutChanges({\n    active,\n    containerId,\n    isDragging,\n    isSorting,\n    id,\n    index,\n    items,\n    newIndex: prevNewIndex.current,\n    previousItems: prevItems.current,\n    previousContainerId: previousContainerId.current,\n    transition,\n    wasDragging: wasDragging.current,\n  });\n  const derivedTransform = useDerivedTransform({\n    disabled: !shouldAnimateLayoutChanges,\n    index,\n    node,\n    rect,\n  });\n\n  useEffect(() => {\n    if (isSorting && prevNewIndex.current !== newIndex) {\n      prevNewIndex.current = newIndex;\n    }\n\n    if (containerId !== previousContainerId.current) {\n      previousContainerId.current = containerId;\n    }\n\n    if (items !== prevItems.current) {\n      prevItems.current = items;\n    }\n  }, [isSorting, newIndex, containerId, items]);\n\n  return {\n    active,\n    attributes,\n    activatorEvent,\n    rect,\n    index,\n    isSorting,\n    isDragging,\n    listeners,\n    node,\n    overIndex,\n    over,\n    setNodeRef,\n    setDroppableNodeRef,\n    setDraggableNodeRef,\n    transform: derivedTransform ?? finalTransform,\n    transition: getTransition(),\n  };\n\n  function getTransition() {\n    if (\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      derivedTransform ||\n      // Or to prevent items jumping to back to their \"new\" position when items change\n      (itemsHaveChanged && prevNewIndex.current === index)\n    ) {\n      return disabledTransition;\n    }\n\n    if (shouldDisplaceDragSource || !transition) {\n      return undefined;\n    }\n\n    if (isSorting || shouldAnimateLayoutChanges) {\n      return CSS.Transition.toString({\n        ...transition,\n        property: transitionProperty,\n      });\n    }\n\n    return undefined;\n  }\n}\n","import {useEffect, useRef, useState} from 'react';\nimport {getBoundingClientRect, LayoutRect} from '@dnd-kit/core';\nimport {Transform, useIsomorphicLayoutEffect} from '@dnd-kit/utilities';\n\ninterface Arguments {\n  rect: React.MutableRefObject<LayoutRect | null>;\n  disabled: boolean;\n  index: number;\n  node: React.MutableRefObject<HTMLElement | null>;\n}\n\n/*\n * When the index of an item changes while sorting,\n * we need to temporarily disable the transforms\n */\nexport function useDerivedTransform({disabled, index, node, rect}: Arguments) {\n  const [derivedTransform, setDerivedtransform] = useState<Transform | null>(\n    null\n  );\n  const previousIndex = useRef(index);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!disabled && index !== previousIndex.current && node.current) {\n      const initial = rect.current;\n\n      if (initial) {\n        const current = getBoundingClientRect(node.current);\n\n        const delta = {\n          x: initial.offsetLeft - current.offsetLeft,\n          y: initial.offsetTop - current.offsetTop,\n          scaleX: initial.width / current.width,\n          scaleY: initial.height / current.height,\n        };\n\n        if (delta.x || delta.y) {\n          setDerivedtransform(delta);\n        }\n      }\n    }\n\n    if (index !== previousIndex.current) {\n      previousIndex.current = index;\n    }\n  }, [disabled, index, node, rect]);\n\n  useEffect(() => {\n    if (derivedTransform) {\n      requestAnimationFrame(() => {\n        setDerivedtransform(null);\n      });\n    }\n  }, [derivedTransform]);\n\n  return derivedTransform;\n}\n"],"names":["arrayMove","array","from","to","newArray","slice","splice","length","isValidIndex","index","defaultScale","scaleX","scaleY","rectSortingStrategy","layoutRects","activeIndex","overIndex","newRects","oldRect","newRect","x","offsetLeft","y","offsetTop","width","height","Context","React","createContext","containerId","disableTransforms","items","useDragOverlay","sortedRects","strategy","wasDragging","current","defaultNewIndexGetter","id","indexOf","defaultAnimateLayoutChanges","isSorting","newIndex","previousItems","previousContainerId","transition","defaultTransition","duration","easing","disabledTransition","CSS","Transition","toString","property","defaultAttributes","roleDescription","directions","KeyboardCode","Down","Right","Up","Left","children","userDefinedItems","active","dragOverlay","droppableRects","over","recomputeLayouts","willRecomputeLayouts","useDndContext","useUniqueId","Boolean","rect","useMemo","map","item","isDragging","useRef","previousItemsRef","reduce","accumulator","layoutRect","get","Array","getSortedRects","itemsHaveChanged","arr2","join","useIsomorphicLayoutEffect","useEffect","timeoutId","setTimeout","clearTimeout","contextValue","Provider","value","activeNodeRect","fallbackActiveRect","itemGap","currentRect","previousRect","nextRect","getItemGap","newIndexRect","event","context","droppableContainers","translatedRect","scrollableAncestors","includes","code","preventDefault","filteredContainers","getEnabled","forEach","entry","disabled","node","getViewRect","container","top","push","left","closestId","closestCorners","collisionRect","newNode","_droppableContainers$","hasDifferentScrollAncestors","getScrollableAncestors","some","element","offset","animateLayoutChanges","attributes","userDefinedAttributes","data","customData","getNewIndex","localStrategy","globalStrategy","useContext","sortable","setNodeRef","setDroppableNodeRef","useDroppable","activatorEvent","setDraggableNodeRef","listeners","transform","useDraggable","useCombinedRefs","displaceItem","shouldDisplaceDragSource","dragSourceDisplacement","finalTransform","prevItems","prevNewIndex","shouldAnimateLayoutChanges","derivedTransform","setDerivedtransform","useState","previousIndex","initial","getBoundingClientRect","delta","requestAnimationFrame","useDerivedTransform","overIndexRect"],"mappings":"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"}